name: Build and Push to ACR

on:
  push:
    branches:
      - main
      - basics
      - local
  pull_request:
    branches:
      - main
      - basics
      - local
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type (major, minor, patch)'
        required: false
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch

env:
  ACR_REPO: chat-frontend
  DAGGER_VERSION: 0.18.10

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Dagger
      run: |
        curl -fsSL https://dl.dagger.io/dagger/install.sh | sh
        sudo mv bin/dagger /usr/local/bin
        dagger version

    - name: Get next version
      id: version
      uses: paulhatch/semantic-version@v5.4.0
      with:
        # The prefix to use to identify tags
        tag_prefix: "v"
        # A string which, if present in a commit, indicates a major version change
        major_pattern: "(MAJOR)"
        # A string which, if present in a commit, indicates a minor version change
        minor_pattern: "(MINOR)"
        # If true, the body of commits will also be searched for major/minor patterns
        search_commit_body: true
        # Pattern to use if branch name should be included in version
        # branch_format: "${branch}"
        # If this is set to true, *every* commit will be treated as a new version.
        bump_each_commit: false
        # If bump_each_commit is true, commit messages are still searched for patterns
        # This enables committers to "skip" a version bump by using a pattern
        enable_prerelease_mode: false
        # Format of the version output
        version_format: "${major}.${minor}.${patch}"
        # Optional path to check for changes. If any changes are detected in the path the
        # version will be bumped.
        # change_path: "src/"
        # Named version, will be used as suffix for name version tag
        # namespace: "my-app"
        # If set to false, the action will not create a git tag for the version
        # tag_on_release: true

    - name: Handle version override for workflow_dispatch
      id: final_version
      run: |
        # For workflow_dispatch, check if we need to force a major/minor bump
        if [ "${{ github.event_name }}" == "workflow_dispatch" ] && [ "${{ github.event.inputs.version_bump }}" != "patch" ]; then
          CURRENT_VERSION="${{ steps.version.outputs.version }}"
          BUMP_TYPE="${{ github.event.inputs.version_bump }}"
          
          # Parse current version
          IFS='.' read -r MAJOR MINOR PATCH <<< "$CURRENT_VERSION"
          
          # Apply the requested bump
          if [ "$BUMP_TYPE" == "major" ]; then
            MAJOR=$((MAJOR + 1))
            MINOR=0
            PATCH=0
          elif [ "$BUMP_TYPE" == "minor" ]; then
            MINOR=$((MINOR + 1))
            PATCH=0
          fi
          
          FINAL_VERSION="${MAJOR}.${MINOR}.${PATCH}"
          echo "Overriding version from $CURRENT_VERSION to $FINAL_VERSION due to workflow_dispatch"
        else
          FINAL_VERSION="${{ steps.version.outputs.version }}"
        fi
        
        echo "version=${FINAL_VERSION}" >> $GITHUB_OUTPUT
        echo "Final version: ${FINAL_VERSION}"

    - name: Gather build metadata
      id: metadata
      run: |
        echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "commit_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        echo "build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
        echo "commit_message=$(git log -1 --pretty=%B | head -n 1 | tr -d '\n' | cut -c1-100)" >> $GITHUB_OUTPUT
        echo "commit_author=$(git log -1 --pretty=%an)" >> $GITHUB_OUTPUT
        echo "build_number=${{ github.run_number }}" >> $GITHUB_OUTPUT
        echo "repository=${{ github.repository }}" >> $GITHUB_OUTPUT

    - name: Cache Dagger engine
      uses: actions/cache@v4
      with:
        path: ~/.local/share/dagger
        key: ${{ runner.os }}-dagger-${{ env.DAGGER_VERSION }}
        restore-keys: |
          ${{ runner.os }}-dagger-

    - name: Build and push to ACR
      env:
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        POSTGRES_URL: ${{ secrets.POSTGRES_URL }}
        AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
        XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        BLOB_READ_WRITE_TOKEN: ${{ secrets.BLOB_READ_WRITE_TOKEN }}
        REDIS_URL: ${{ secrets.REDIS_URL }}
        TIMEZONE_DB_API_KEY: ${{ secrets.TIMEZONE_DB_API_KEY }}
        NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
        NEON_PROJECT_ID: ${{ secrets.NEON_PROJECT_ID }}
        # Dagger Cloud token for pipeline traces and visualization
        # Traces will be available at https://dagger.cloud
        DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}
      run: |
        cd .dagger
        
        # Run the Dagger pipeline
        dagger call push-to-acr \
          --src-dir .. \
          --acr-name ${{ secrets.ACR_USERNAME }} \
          --repo ${{ env.ACR_REPO }} \
          --tag ${{ steps.final_version.outputs.version }} \
          --username ${{ secrets.ACR_USERNAME }} \
          --password env:ACR_PASSWORD \
          --postgres-url env:POSTGRES_URL \
          --auth-secret env:AUTH_SECRET \
          --xai-key env:XAI_API_KEY \
          --blob-token env:BLOB_READ_WRITE_TOKEN \
          --redis-url env:REDIS_URL \
          --tzdb-key env:TIMEZONE_DB_API_KEY \
          --neon-api-key env:NEON_API_KEY \
          --neon-project-id env:NEON_PROJECT_ID \
          --git-commit-sha "${{ steps.metadata.outputs.commit_sha }}" \
          --git-commit-short "${{ steps.metadata.outputs.commit_short }}" \
          --git-branch "${{ steps.metadata.outputs.branch }}" \
          --build-time "${{ steps.metadata.outputs.build_time }}" \
          --build-version "${{ steps.final_version.outputs.version }}" \
          --git-commit-message "${{ steps.metadata.outputs.commit_message }}" \
          --git-commit-author "${{ steps.metadata.outputs.commit_author }}" \
          --build-number "${{ steps.metadata.outputs.build_number }}" \
          --git-repository "${{ steps.metadata.outputs.repository }}"

    # Version tracking is now done via git tags

    - name: Create Release Tag
      if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/basics')
      run: |
        # Only create tag if one doesn't already exist (semantic-version might have created it)
        if ! git rev-parse "v${{ steps.final_version.outputs.version }}" >/dev/null 2>&1; then
          git tag -a "v${{ steps.final_version.outputs.version }}" -m "Release version ${{ steps.final_version.outputs.version }}"
          git push origin "v${{ steps.final_version.outputs.version }}"
        else
          echo "Tag v${{ steps.final_version.outputs.version }} already exists"
        fi

    - name: Output summary
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ secrets.ACR_USERNAME }}.azurecr.io/${{ env.ACR_REPO }}:${{ steps.final_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.final_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version Type**: ${{ steps.version.outputs.version_type }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Time**: ${{ steps.metadata.outputs.build_time }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Number**: #${{ steps.metadata.outputs.build_number }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Author**: ${{ steps.metadata.outputs.commit_author }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Metadata (embedded in image)" >> $GITHUB_STEP_SUMMARY
        echo "These environment variables are available in the Next.js app:" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_GIT_COMMIT\`: ${{ steps.metadata.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_GIT_BRANCH\`: ${{ steps.metadata.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_BUILD_VERSION\`: ${{ steps.final_version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_BUILD_TIME\`: ${{ steps.metadata.outputs.build_time }}" >> $GITHUB_STEP_SUMMARY