name: Build and Push to ACR

on:
  push:
    branches:
      - main
      - basics
      - local
  pull_request:
    branches:
      - main
      - basics
      - local
  workflow_dispatch:
    inputs:
      version_bump:
        description: 'Version bump type (major, minor, patch)'
        required: false
        default: 'patch'
        type: choice
        options:
          - major
          - minor
          - patch

env:
  ACR_REPO: chat-frontend
  DAGGER_VERSION: 0.18.10

jobs:
  build-and-push:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Dagger
      run: |
        curl -fsSL https://dl.dagger.io/dagger/install.sh | sh
        sudo mv bin/dagger /usr/local/bin
        dagger version

    - name: Determine version bump type
      id: bump_type
      run: |
        if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
          echo "type=${{ github.event.inputs.version_bump }}" >> $GITHUB_OUTPUT
        else
          echo "type=patch" >> $GITHUB_OUTPUT
        fi

    - name: Get latest version from ACR
      id: latest_version
      env:
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
      run: |
        # Login to ACR using docker to query tags
        echo "$ACR_PASSWORD" | docker login ${{ secrets.ACR_USERNAME }}.azurecr.io -u ${{ secrets.ACR_USERNAME }} --password-stdin
        
        # Get manifest for the repository
        REGISTRY="${{ secrets.ACR_USERNAME }}.azurecr.io"
        REPO="${{ env.ACR_REPO }}"
        
        # Use Docker Hub API style endpoint for ACR
        TOKEN=$(echo -n "${{ secrets.ACR_USERNAME }}:$ACR_PASSWORD" | base64)
        
        # Get tags from ACR REST API
        RESPONSE=$(curl -s -H "Authorization: Basic $TOKEN" \
          "https://${REGISTRY}/v2/${REPO}/tags/list")
        
        # Parse tags and find latest semantic version
        LATEST_VERSION=$(echo "$RESPONSE" | jq -r '.tags[]' 2>/dev/null | \
          grep -E '^[0-9]+\.[0-9]+\.[0-9]+$' | \
          sort -V | tail -1)
        
        # Default to 0.0.0 if no version found
        if [ -z "$LATEST_VERSION" ]; then
          echo "No existing versions found in ACR, starting from 0.0.0"
          LATEST_VERSION="0.0.0"
        fi
        
        echo "latest=${LATEST_VERSION}" >> $GITHUB_OUTPUT
        echo "Latest version in ACR: ${LATEST_VERSION}"

    - name: Bump version
      id: version
      run: |
        # Make bump-version-acr.sh executable
        chmod +x ./scripts/bump-version-acr.sh
        
        # Bump the version based on latest from ACR
        NEW_VERSION=$(./scripts/bump-version-acr.sh ${{ steps.latest_version.outputs.latest }} ${{ steps.bump_type.outputs.type }})
        echo "version=${NEW_VERSION}" >> $GITHUB_OUTPUT
        echo "New version: ${NEW_VERSION}"

    - name: Gather build metadata
      id: metadata
      run: |
        echo "commit_sha=${{ github.sha }}" >> $GITHUB_OUTPUT
        echo "commit_short=$(git rev-parse --short HEAD)" >> $GITHUB_OUTPUT
        echo "branch=${{ github.ref_name }}" >> $GITHUB_OUTPUT
        echo "build_time=$(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> $GITHUB_OUTPUT
        echo "commit_message=$(git log -1 --pretty=%B | head -n 1 | tr -d '\n' | cut -c1-100)" >> $GITHUB_OUTPUT
        echo "commit_author=$(git log -1 --pretty=%an)" >> $GITHUB_OUTPUT
        echo "build_number=${{ github.run_number }}" >> $GITHUB_OUTPUT
        echo "repository=${{ github.repository }}" >> $GITHUB_OUTPUT

    - name: Cache Dagger engine
      uses: actions/cache@v4
      with:
        path: ~/.local/share/dagger
        key: ${{ runner.os }}-dagger-${{ env.DAGGER_VERSION }}
        restore-keys: |
          ${{ runner.os }}-dagger-

    - name: Build and push to ACR
      env:
        ACR_PASSWORD: ${{ secrets.ACR_PASSWORD }}
        ACR_USERNAME: ${{ secrets.ACR_USERNAME }}
        POSTGRES_URL: ${{ secrets.POSTGRES_URL }}
        AUTH_SECRET: ${{ secrets.AUTH_SECRET }}
        XAI_API_KEY: ${{ secrets.XAI_API_KEY }}
        BLOB_READ_WRITE_TOKEN: ${{ secrets.BLOB_READ_WRITE_TOKEN }}
        REDIS_URL: ${{ secrets.REDIS_URL }}
        TIMEZONE_DB_API_KEY: ${{ secrets.TIMEZONE_DB_API_KEY }}
        NEON_API_KEY: ${{ secrets.NEON_API_KEY }}
        NEON_PROJECT_ID: ${{ secrets.NEON_PROJECT_ID }}
        # Dagger Cloud token for pipeline traces and visualization
        # Traces will be available at https://dagger.cloud
        DAGGER_CLOUD_TOKEN: ${{ secrets.DAGGER_CLOUD_TOKEN }}
      run: |
        cd .dagger
        
        # Run the Dagger pipeline
        dagger call push-to-acr \
          --src-dir .. \
          --acr-name ${{ secrets.ACR_USERNAME }} \
          --repo ${{ env.ACR_REPO }} \
          --tag ${{ steps.version.outputs.version }} \
          --username ${{ secrets.ACR_USERNAME }} \
          --password env:ACR_PASSWORD \
          --postgres-url env:POSTGRES_URL \
          --auth-secret env:AUTH_SECRET \
          --xai-key env:XAI_API_KEY \
          --blob-token env:BLOB_READ_WRITE_TOKEN \
          --redis-url env:REDIS_URL \
          --tzdb-key env:TIMEZONE_DB_API_KEY \
          --neon-api-key env:NEON_API_KEY \
          --neon-project-id env:NEON_PROJECT_ID \
          --git-commit-sha "${{ steps.metadata.outputs.commit_sha }}" \
          --git-commit-short "${{ steps.metadata.outputs.commit_short }}" \
          --git-branch "${{ steps.metadata.outputs.branch }}" \
          --build-time "${{ steps.metadata.outputs.build_time }}" \
          --build-version "${{ steps.version.outputs.version }}" \
          --git-commit-message "${{ steps.metadata.outputs.commit_message }}" \
          --git-commit-author "${{ steps.metadata.outputs.commit_author }}" \
          --build-number "${{ steps.metadata.outputs.build_number }}" \
          --git-repository "${{ steps.metadata.outputs.repository }}"

    # Version tracking is now done via ACR tags, no need to commit .version file

    - name: Create Release Tag
      if: github.event_name == 'push' && (github.ref == 'refs/heads/main' || github.ref == 'refs/heads/basics')
      run: |
        git tag -a "v${{ steps.version.outputs.version }}" -m "Release version ${{ steps.version.outputs.version }}"
        git push origin "v${{ steps.version.outputs.version }}"

    - name: Output summary
      run: |
        echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "- **Image**: ${{ secrets.ACR_USERNAME }}.azurecr.io/${{ env.ACR_REPO }}:${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Version**: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Branch**: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Commit**: ${{ github.sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Time**: ${{ steps.metadata.outputs.build_time }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Build Number**: #${{ steps.metadata.outputs.build_number }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Author**: ${{ steps.metadata.outputs.commit_author }}" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "### Build Metadata (embedded in image)" >> $GITHUB_STEP_SUMMARY
        echo "These environment variables are available in the Next.js app:" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_GIT_COMMIT\`: ${{ steps.metadata.outputs.commit_sha }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_GIT_BRANCH\`: ${{ steps.metadata.outputs.branch }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_BUILD_VERSION\`: ${{ steps.version.outputs.version }}" >> $GITHUB_STEP_SUMMARY
        echo "- \`NEXT_PUBLIC_BUILD_TIME\`: ${{ steps.metadata.outputs.build_time }}" >> $GITHUB_STEP_SUMMARY